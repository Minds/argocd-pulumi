// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Immutable;

namespace Pulumi.Argocd
{
    public static class Config
    {
        [global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "IDE1006", Justification = 
        "Double underscore prefix used to avoid conflicts with variable names.")]
        private sealed class __Value<T>
        {
            private readonly Func<T> _getter;
            private T _value = default!;
            private bool _set;

            public __Value(Func<T> getter)
            {
                _getter = getter;
            }

            public T Get() => _set ? _value : _getter();

            public void Set(T value)
            {
                _value = value;
                _set = true;
            }
        }

        private static readonly global::Pulumi.Config __config = new global::Pulumi.Config("argocd");

        private static readonly __Value<string?> _authToken = new __Value<string?>(() => __config.Get("authToken"));
        /// <summary>
        /// ArgoCD authentication token, takes precedence over `username`/`password`. Can be set through the `ARGOCD_AUTH_TOKEN`
        /// environment variable.
        /// </summary>
        public static string? AuthToken
        {
            get => _authToken.Get();
            set => _authToken.Set(value);
        }

        private static readonly __Value<string?> _certFile = new __Value<string?>(() => __config.Get("certFile"));
        /// <summary>
        /// Additional root CA certificates file to add to the client TLS connection pool.
        /// </summary>
        public static string? CertFile
        {
            get => _certFile.Get();
            set => _certFile.Set(value);
        }

        private static readonly __Value<string?> _clientCertFile = new __Value<string?>(() => __config.Get("clientCertFile"));
        /// <summary>
        /// Client certificate.
        /// </summary>
        public static string? ClientCertFile
        {
            get => _clientCertFile.Get();
            set => _clientCertFile.Set(value);
        }

        private static readonly __Value<string?> _clientCertKey = new __Value<string?>(() => __config.Get("clientCertKey"));
        /// <summary>
        /// Client certificate key.
        /// </summary>
        public static string? ClientCertKey
        {
            get => _clientCertKey.Get();
            set => _clientCertKey.Set(value);
        }

        private static readonly __Value<string?> _configPath = new __Value<string?>(() => __config.Get("configPath"));
        /// <summary>
        /// Override the default config path of `$HOME/.config/argocd/config`. Only relevant when `use_local_config`. Can be set
        /// through the `ARGOCD_CONFIG_PATH` environment variable.
        /// </summary>
        public static string? ConfigPath
        {
            get => _configPath.Get();
            set => _configPath.Set(value);
        }

        private static readonly __Value<string?> _context = new __Value<string?>(() => __config.Get("context"));
        /// <summary>
        /// Context to choose when using a local ArgoCD config file. Only relevant when `use_local_config`. Can be set through
        /// `ARGOCD_CONTEXT` environment variable.
        /// </summary>
        public static string? Context
        {
            get => _context.Get();
            set => _context.Set(value);
        }

        private static readonly __Value<bool?> _core = new __Value<bool?>(() => __config.GetBoolean("core"));
        /// <summary>
        /// Configure direct access using Kubernetes API server. **Warning**: this feature works by starting a local ArgoCD API
        /// server that talks directly to the Kubernetes API using the **current context in the default kubeconfig**
        /// (`~/.kube/config`). This behavior cannot be overridden using either environment variables or the `kubernetes` block in
        /// the provider configuration at present). If the server fails to start (e.g. your kubeconfig is misconfigured) then the
        /// provider will fail as a result of the `argocd` module forcing it to exit and no logs will be available to help you debug
        /// this. The error message will be similar to &gt; `The plugin encountered an error, and failed to respond to the
        /// plugin.(*GRPCProvider).ReadResource call. The plugin logs may contain more details.` To debug this, you will need to
        /// login via the ArgoCD CLI using `argocd login --core` and then running an operation. E.g. `argocd app list`.
        /// </summary>
        public static bool? Core
        {
            get => _core.Get();
            set => _core.Set(value);
        }

        private static readonly __Value<bool?> _grpcWeb = new __Value<bool?>(() => __config.GetBoolean("grpcWeb"));
        /// <summary>
        /// Whether to use gRPC web proxy client. Useful if Argo CD server is behind proxy which does not support HTTP2.
        /// </summary>
        public static bool? GrpcWeb
        {
            get => _grpcWeb.Get();
            set => _grpcWeb.Set(value);
        }

        private static readonly __Value<string?> _grpcWebRootPath = new __Value<string?>(() => __config.Get("grpcWebRootPath"));
        /// <summary>
        /// Use the gRPC web proxy client and set the web root, e.g. `argo-cd`. Useful if the Argo CD server is behind a proxy at a
        /// non-root path.
        /// </summary>
        public static string? GrpcWebRootPath
        {
            get => _grpcWebRootPath.Get();
            set => _grpcWebRootPath.Set(value);
        }

        private static readonly __Value<ImmutableArray<string>> _headers = new __Value<ImmutableArray<string>>(() => __config.GetObject<ImmutableArray<string>>("headers"));
        /// <summary>
        /// Additional headers to add to each request to the ArgoCD server.
        /// </summary>
        public static ImmutableArray<string> Headers
        {
            get => _headers.Get();
            set => _headers.Set(value);
        }

        private static readonly __Value<bool?> _insecure = new __Value<bool?>(() => __config.GetBoolean("insecure"));
        /// <summary>
        /// Whether to skip TLS server certificate. Can be set through the `ARGOCD_INSECURE` environment variable.
        /// </summary>
        public static bool? Insecure
        {
            get => _insecure.Get();
            set => _insecure.Set(value);
        }

        private static readonly __Value<Pulumi.Argocd.Config.Types.Kubernetes?> _kubernetes = new __Value<Pulumi.Argocd.Config.Types.Kubernetes?>(() => __config.GetObject<Pulumi.Argocd.Config.Types.Kubernetes>("kubernetes"));
        /// <summary>
        /// Kubernetes configuration overrides. Only relevant when `port_forward = true` or `port_forward_with_namespace = "foo"`.
        /// The kubeconfig file that is used can be overridden using the [`KUBECONFIG` environment
        /// variable](https://kubernetes.io/docs/concepts/configuration/organize-cluster-access-kubeconfig/#the-kubeconfig-environment-variable)).
        /// </summary>
        public static Pulumi.Argocd.Config.Types.Kubernetes? Kubernetes
        {
            get => _kubernetes.Get();
            set => _kubernetes.Set(value);
        }

        private static readonly __Value<string?> _password = new __Value<string?>(() => __config.Get("password"));
        /// <summary>
        /// Authentication password. Can be set through the `ARGOCD_AUTH_PASSWORD` environment variable.
        /// </summary>
        public static string? Password
        {
            get => _password.Get();
            set => _password.Set(value);
        }

        private static readonly __Value<bool?> _plainText = new __Value<bool?>(() => __config.GetBoolean("plainText"));
        /// <summary>
        /// Whether to initiate an unencrypted connection to ArgoCD server.
        /// </summary>
        public static bool? PlainText
        {
            get => _plainText.Get();
            set => _plainText.Set(value);
        }

        private static readonly __Value<bool?> _portForward = new __Value<bool?>(() => __config.GetBoolean("portForward"));
        /// <summary>
        /// Connect to a random argocd-server port using port forwarding.
        /// </summary>
        public static bool? PortForward
        {
            get => _portForward.Get();
            set => _portForward.Set(value);
        }

        private static readonly __Value<string?> _portForwardWithNamespace = new __Value<string?>(() => __config.Get("portForwardWithNamespace"));
        /// <summary>
        /// Namespace name which should be used for port forwarding.
        /// </summary>
        public static string? PortForwardWithNamespace
        {
            get => _portForwardWithNamespace.Get();
            set => _portForwardWithNamespace.Set(value);
        }

        private static readonly __Value<string?> _serverAddr = new __Value<string?>(() => __config.Get("serverAddr"));
        /// <summary>
        /// ArgoCD server address with port. Can be set through the `ARGOCD_SERVER` environment variable.
        /// </summary>
        public static string? ServerAddr
        {
            get => _serverAddr.Get();
            set => _serverAddr.Set(value);
        }

        private static readonly __Value<bool?> _useLocalConfig = new __Value<bool?>(() => __config.GetBoolean("useLocalConfig"));
        /// <summary>
        /// Use the authentication settings found in the local config file. Useful when you have previously logged in using SSO.
        /// Conflicts with `auth_token`, `username` and `password`.
        /// </summary>
        public static bool? UseLocalConfig
        {
            get => _useLocalConfig.Get();
            set => _useLocalConfig.Set(value);
        }

        private static readonly __Value<string?> _userAgent = new __Value<string?>(() => __config.Get("userAgent"));
        /// <summary>
        /// User-Agent request header override.
        /// </summary>
        public static string? UserAgent
        {
            get => _userAgent.Get();
            set => _userAgent.Set(value);
        }

        private static readonly __Value<string?> _username = new __Value<string?>(() => __config.Get("username"));
        /// <summary>
        /// Authentication username. Can be set through the `ARGOCD_AUTH_USERNAME` environment variable.
        /// </summary>
        public static string? Username
        {
            get => _username.Get();
            set => _username.Set(value);
        }

        public static class Types
        {

             public class Kubernetes
             {
            /// <summary>
            /// PEM-encoded client certificate for TLS authentication. Can be sourced from `KUBE_CLIENT_CERT_DATA`.
            /// </summary>
                public string? ClientCertificate { get; set; } = null!;
            /// <summary>
            /// PEM-encoded client certificate key for TLS authentication. Can be sourced from `KUBE_CLIENT_KEY_DATA`.
            /// </summary>
                public string? ClientKey { get; set; } = null!;
            /// <summary>
            /// PEM-encoded root certificates bundle for TLS authentication. Can be sourced from `KUBE_CLUSTER_CA_CERT_DATA`.
            /// </summary>
                public string? ClusterCaCertificate { get; set; } = null!;
            /// <summary>
            /// Context to choose from the config file. Can be sourced from `KUBE_CTX`.
            /// </summary>
                public string? ConfigContext { get; set; } = null!;
                public string? ConfigContextAuthInfo { get; set; } = null!;
                public string? ConfigContextCluster { get; set; } = null!;
            /// <summary>
            /// Configuration block to use an [exec-based credential plugin](https://kubernetes.io/docs/reference/access-authn-authz/authentication/#client-go-credential-plugins), e.g. call an external command to receive user credentials.
            /// </summary>
                public Pulumi.Argocd.Config.Types.KubernetesExec? Exec { get; set; } = null!;
            /// <summary>
            /// The hostname (in form of URI) of the Kubernetes API. Can be sourced from `KUBE_HOST`.
            /// </summary>
                public string? Host { get; set; } = null!;
            /// <summary>
            /// Whether server should be accessed without verifying the TLS certificate. Can be sourced from `KUBE_INSECURE`.
            /// </summary>
                public bool? Insecure { get; set; }
            /// <summary>
            /// The password to use for HTTP basic authentication when accessing the Kubernetes API. Can be sourced from `KUBE_PASSWORD`.
            /// </summary>
                public string? Password { get; set; } = null!;
            /// <summary>
            /// Token to authenticate an service account. Can be sourced from `KUBE_TOKEN`.
            /// </summary>
                public string? Token { get; set; } = null!;
            /// <summary>
            /// The username to use for HTTP basic authentication when accessing the Kubernetes API. Can be sourced from `KUBE_USER`.
            /// </summary>
                public string? Username { get; set; } = null!;
            }

             public class KubernetesExec
             {
            /// <summary>
            /// API version to use when decoding the ExecCredentials resource, e.g. `client.authentication.k8s.io/v1beta1`.
            /// </summary>
                public string ApiVersion { get; set; }
            /// <summary>
            /// Map of environment variables to set when executing the plugin.
            /// </summary>
                public ImmutableArray<string> Args { get; set; }
            /// <summary>
            /// Command to execute.
            /// </summary>
                public string Command { get; set; }
            /// <summary>
            /// List of arguments to pass when executing the plugin.
            /// </summary>
                public ImmutableDictionary<string, string>? Env { get; set; } = null!;
            }
        }
    }
}
